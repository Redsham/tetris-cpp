<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/include/grid.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/grid.h" />
              <option name="originalContent" value="#ifndef GRID_H&#10;#define GRID_H&#10;&#10;#include &quot;vector.h&quot;&#10;&#10;template&lt;typename T&gt;&#10;struct Grid {&#10;    Grid(): data(nullptr), width(0), height(0) {&#10;    }&#10;    Grid(const int w, const int h) : width(w), height(h) {&#10;        data = new T[width * height]; // Allocate memory for the grid&#10;    }&#10;    ~Grid() { delete[] data; }&#10;&#10;    Grid(const Grid &amp;other);&#10;    Grid &amp;operator=(const Grid &amp;other);&#10;&#10;    Grid(Grid &amp;&amp;other) noexcept;&#10;    Grid &amp;operator=(Grid &amp;&amp;other) noexcept;&#10;&#10;    [[nodiscard]] int get_width() const { return width; }         // Get the width of the grid&#10;    [[nodiscard]] int get_height() const { return height; }       // Get the height of the grid&#10;    [[nodiscard]] int get_size() const { return width * height; } // Get the total number of elements in the grid&#10;    [[nodiscard]] int get_index(const int x, const int y) const { return y * width + x; }&#10;    // Calculate the index in the data array&#10;    [[nodiscard]] int get_index(const Vec2 &amp;pos) const { return get_index(pos.x, pos.y); }&#10;    // Calculate the index in the data array from a Vec2 position&#10;    T *get_raw() const { return data; } // Get a pointer to the raw data of the grid&#10;&#10;    void fill(const T &amp;value); // Fill the grid with a specific value&#10;&#10;    Grid rotate_clockwise() const;         // Rotate clockwise by 90 degrees and return a new Grid&#10;    Grid rotate_counter_clockwise() const; // Rotate counter-clockwise by 90 degrees and return a new Grid&#10;&#10;    T &amp;      operator()(const int x, const int y) { return data[y * width + x]; } // Access grid element at (x, y)&#10;    T &amp;      operator()(const Vec2 &amp;pos) { return (*this)(pos.x, pos.y); } // Access grid element at Vec2 position&#10;    const T &amp;operator()(const int x, const int y) const { return data[y * width + x]; } // Access grid element at (x, y)&#10;    const T &amp;operator()(const Vec2 &amp;pos) const { return (*this)(pos.x, pos.y); } // Access grid element at Vec2 position&#10;&#10;private:&#10;    T * data;   // Pointer to the grid data&#10;    int width;  // Width of the grid&#10;    int height; // Height of the grid&#10;};&#10;&#10;#endif //GRID_H&#10;" />
              <option name="updatedContent" value="#ifndef GRID_H&#10;#define GRID_H&#10;&#10;#include &quot;vector.h&quot;&#10;#include &lt;algorithm&gt;&#10;&#10;template&lt;typename T&gt;&#10;struct Grid {&#10;    Grid(): data(nullptr), width(0), height(0) {&#10;    }&#10;    Grid(const int w, const int h) : width(w), height(h) {&#10;        data = new T[width * height];&#10;    }&#10;    ~Grid() { delete[] data; }&#10;&#10;    Grid(const Grid &amp;other);&#10;    Grid &amp;operator=(const Grid &amp;other);&#10;&#10;    Grid(Grid &amp;&amp;other) noexcept;&#10;    Grid &amp;operator=(Grid &amp;&amp;other) noexcept;&#10;&#10;    [[nodiscard]] int get_width() const { return width; }&#10;    [[nodiscard]] int get_height() const { return height; }&#10;    [[nodiscard]] int get_size() const { return width * height; }&#10;    [[nodiscard]] int get_index(const int x, const int y) const { return y * width + x; }&#10;    [[nodiscard]] int get_index(const Vec2 &amp;pos) const { return get_index(pos.x, pos.y); }&#10;    T *get_raw() const { return data; }&#10;&#10;    void fill(const T &amp;value);&#10;&#10;    Grid rotate_clockwise() const;&#10;    Grid rotate_counter_clockwise() const;&#10;&#10;    T &amp;      operator()(const int x, const int y) { return data[y * width + x]; }&#10;    T &amp;      operator()(const Vec2 &amp;pos) { return (*this)(pos.x, pos.y); }&#10;    const T &amp;operator()(const int x, const int y) const { return data[y * width + x]; }&#10;    const T &amp;operator()(const Vec2 &amp;pos) const { return (*this)(pos.x, pos.y); }&#10;&#10;private:&#10;    T * data;&#10;    int width;&#10;    int height;&#10;};&#10;&#10;// Реализации методов шаблона&#10;&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt;::Grid(const Grid &amp;other) : width(other.width), height(other.height) {&#10;    data = new T[width * height];&#10;    std::copy(other.data, other.data + width * height, data);&#10;}&#10;&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt; &amp;Grid&lt;T&gt;::operator=(const Grid &amp;other) {&#10;    if (this != &amp;other) {&#10;        delete[] data;&#10;        width  = other.width;&#10;        height = other.height;&#10;        data   = new T[width * height];&#10;        std::copy(other.data, other.data + width * height, data);&#10;    }&#10;    return *this;&#10;}&#10;&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt;::Grid(Grid &amp;&amp;other) noexcept : data(other.data), width(other.width), height(other.height) {&#10;    other.data   = nullptr;&#10;    other.width  = 0;&#10;    other.height = 0;&#10;}&#10;&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt; &amp;Grid&lt;T&gt;::operator=(Grid &amp;&amp;other) noexcept {&#10;    if (this != &amp;other) {&#10;        delete[] data;&#10;        data         = other.data;&#10;        width        = other.width;&#10;        height       = other.height;&#10;        other.data   = nullptr;&#10;        other.width  = 0;&#10;        other.height = 0;&#10;    }&#10;    return *this;&#10;}&#10;&#10;template&lt;typename T&gt;&#10;void Grid&lt;T&gt;::fill(const T &amp;value) {&#10;    for (int i = 0; i &lt; width * height; ++i) {&#10;        data[i] = value;&#10;    }&#10;}&#10;&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt; Grid&lt;T&gt;::rotate_clockwise() const {&#10;    Grid rotated(height, width);&#10;    for (int y = 0; y &lt; height; ++y) {&#10;        for (int x = 0; x &lt; width; ++x) {&#10;            rotated.data[x * height + (height - 1 - y)] = data[y * width + x];&#10;        }&#10;    }&#10;    return rotated;&#10;}&#10;&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt; Grid&lt;T&gt;::rotate_counter_clockwise() const {&#10;    Grid rotated(height, width);&#10;    for (int y = 0; y &lt; height; ++y) {&#10;        for (int x = 0; x &lt; width; ++x) {&#10;            rotated.data[(width - 1 - x) * height + y] = data[y * width + x];&#10;        }&#10;    }&#10;    return rotated;&#10;}&#10;&#10;#endif //GRID_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/grid.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/grid.cpp" />
              <option name="originalContent" value="#include &quot;grid.h&quot;&#10;&#10;#include &lt;algorithm&gt;&#10;&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt;::Grid(const Grid &amp;other) : width(other.width), height(other.height) {&#10;    data = new T[width * height]; // Allocate memory for the grid&#10;    std::copy(other.data, other.data + width * height, data);&#10;}&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt; &amp;Grid&lt;T&gt;::operator=(const Grid &amp;other) {&#10;    if (this != &amp;other) {&#10;        delete[] data; // Free existing memory&#10;        width  = other.width;&#10;        height = other.height;&#10;        data   = new T[width * height]; // Allocate new memory&#10;        std::copy(other.data, other.data + width * height, data);&#10;    }&#10;    return *this;&#10;}&#10;&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt;::Grid(Grid &amp;&amp;other) noexcept : data(other.data), width(other.width), height(other.height) {&#10;    other.data   = nullptr; // Transfer ownership&#10;    other.width  = 0;&#10;    other.height = 0;&#10;}&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt; &amp;Grid&lt;T&gt;::operator=(Grid &amp;&amp;other) noexcept {&#10;    if (this != &amp;other) {&#10;        delete[] data;             // Free existing memory&#10;        data         = other.data; // Transfer ownership&#10;        width        = other.width;&#10;        height       = other.height;&#10;        other.data   = nullptr; // Nullify the moved-from object&#10;        other.width  = 0;&#10;        other.height = 0;&#10;    }&#10;    return *this;&#10;}&#10;&#10;&#10;template&lt;typename T&gt;&#10;void Grid&lt;T&gt;::fill(const T &amp;value) {&#10;    for (int i = 0; i &lt; width * height; ++i) {&#10;        data[i] = value;&#10;    }&#10;}&#10;&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt; Grid&lt;T&gt;::rotate_clockwise() const {&#10;    Grid rotated(height, width);&#10;    for (int y = 0; y &lt; height; ++y) {&#10;        for (int x = 0; x &lt; width; ++x) {&#10;            rotated.data[x * height + (height - 1 - y)] = data[y * width + x];&#10;        }&#10;    }&#10;    return rotated;&#10;}&#10;template&lt;typename T&gt;&#10;Grid&lt;T&gt; Grid&lt;T&gt;::rotate_counter_clockwise() const {&#10;    Grid rotated(height, width);&#10;    for (int y = 0; y &lt; height; ++y) {&#10;        for (int x = 0; x &lt; width; ++x) {&#10;            rotated.data[(width - 1 - x) * height + y] = data[y * width + x];&#10;        }&#10;    }&#10;    return rotated;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="// Файл больше не нужен, все реализации перенесены в grid.h" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>